// SETI 1.5 Steering Script 
// Modified from Yiqun Ma's Tiling-all-in-one-folder.bsh
// By Niklas Gahm
// 2021/10/13

// Notes for Upgrading to SETI 2.0
// - at various points there's specific comments about things that should be updated for 2.0 marked with ------------------ at the end
// - any reference to arduino needs to be removed
// - wait times may be unnecessary since uManager theoretically knows when some step is completed

// Imports
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.List;
import java.lang.String;
import ij.IJ; 
//import java.lang.

//import java.io.IOException;
//import java.nio.file.Path;
//import java.nio.file.Paths;
//import java.nio.file.Files;
//import java.awt.image;
//import javax.imageio.ImageIO;



//------------------ INPUTS ----------------------------------------
inputs(){
	
	int depth = 10;// total depth of physical sectioning in um (10um per cut).
								//eg: 200 for 200um and 20 cuts
	int depthOfSectioning = 1; // including the top surface, how many optical slices (10 um each)?  
	int tilingDim = 3;
	
	// set camera exposure in ms				
	double exposure = 1; 
	int objective = 20;
	int xTiles = 3;		// NOTE: matched G Code only supports 3x3 at the moment 
	int yTiles = 3;
	int zStepSize = 10; // in um 

	String acquName = "2018-11-20-Tissue-14Bit-20MHz-Tiling-Highlighter-2";  //name of folder generated
	
	
	// NOTE! All File paths must use / or \\ instead of \ on Windows
	
	String rootDir = "C:/Users/admin2/Box Sync/SETI/";
	//rootDir = "C:/Users/admin2/Desktop/Acquisitions"; //address of mother folder
	
	String dlpPatternPath = "C:/Users/User/Documents/GitHub/SETI/Steering Code/Patterns/1920x1080/3 Sub Image Perfect Bar 21 Pixels 0 Aperture 0deg Rotation";	// Folder Containg Patterns for DLP

	show = true;	// to display every image taken as if you clicked snap
	save = true;	// to save the images
	validity_check = true; // to print various checks to the command line 

	return this;
}
//--------------- END INPUT ----------------------------------------





// Methods
imgFileSearch( String fileType, File folder, ArrayList result ){
	
	File[] files = folder.listFiles();
	if (files !=null){
		for (File f : files){
			if (f.isFile()) {
				if (f.getName().matches(fileType)) {
					result.add(f.getAbsolutePath());
				}
			}
		}
	}

	return result; 
}

// Find the BrightField Reference File
bfImgFileSearch( String fileType, String folder, boolean validity_check ){

	
	bfpath = 1;
	if (validity_check){
		print("System File Seperator: " + File.separator);
	}
	folder = folder.replace("\\", File.separator);
	folder = folder.replace("/", File.separator);
	
	if (validity_check){
		print(folder);
	}
	
	int sep = folder.lastIndexOf(File.separator);
	folder = folder.substring(0,sep);
	// Check seperator is correct
	if (validity_check){
		print(folder);
	}

	File bfpath = new File(folder);
	File[] files = bfpath.listFiles();
	if (files !=null){
		for (File f : files){
			if (f.isFile()) {
				if (f.getName().matches(fileType)) {
					 return f.getAbsolutePath();
				}
			}
		}
	}
	
	return bfpath;
}

// Load all the Patterns Found into a Single Array
loadAllPatterns(String bfPattern, ArrayList subPatterns, ArrayList dlp_patterns, boolean validity_check) {

	dlp_patterns.add(IJ.openImage(bfPattern));
	for (p : subPatterns ){
		dlp_patterns.add(IJ.openImage(p));
	}

	if (validity_check){
		print("Number of Patterns Total: " + dlp_patterns.size());
	}

	return dlp_patterns;
}

// Initialize the DLP Patterns
dlpPatternInitialization(String dlpPatternPathOrig, Boolean validity_check){

	ArrayList img_load_list = new ArrayList();
	File dlpPatternPath = new File(dlpPatternPathOrig);
	// Check correct folder
	if (validity_check){
		print(dlpPatternPath);
	}

	// Get Path to Sub-Image Patterns
	img_load_list = imgFileSearch( ".*.bmp", dlpPatternPath, img_load_list );
	// Get Path to BrightField Reference File
	bf_path = bfImgFileSearch(".*\\.bmp", dlpPatternPathOrig, validity_check);
	//Check correct files found
	if (validity_check){
		for (int i = 0; i < img_load_list.size(); i++){
		  print(img_load_list.get(i));
		}
		print(bf_path);
	}


	// Load Patterns for the DLP
	ArrayList dlp_patterns = new ArrayList();
	dlp_patterns = loadAllPatterns(bf_path, img_load_list, dlp_patterns, validity_check);
	return dlp_patterns;
}











//--------------------------------- CODE BELOW NEEDS TESTING ON THE SETI SYSTEM --------------------
switchPattern(String slmLabel, pattern){
	//set shutter open
	mmc.setShutterOpen(true);
	mmc.setSLMImage(slmLabel, pattern);
	mmc.displaySLMImage(slmLabel);
	//make sure that dlp is on
	mmc.sleep(50); 
	return true; 
}

// Replace the next three methods with milling control in 2.0 ------------------------------------------------
activateMill(){
	mmc.setState("Arduino-Switch", 32);  //pin 13 HIGH, triggers milling cycle (pin 15 on mill)
	mmc.setShutterOpen(true);
	return true;
}

waitForMillingStart(){
	//wait for signal from mill to signal the beginning of a cycle (M140)
	while(Double.valueOf(mmc.getProperty("Arduino-Input", "AnalogInput5")) > 500){
		print("ACTIVATING MILL");
		mmc.sleep(50);
		//gui.message(mmc.getProperty("Arduino-Input", "AnalogInput3"));
	}
	return true;
}

shutterOff(){
	//once milling cycle has started, shutter off
	mmc.setShutterOpen(false);
	mmc.setState("Arduino-Switch", 0);	//all pins LOW
}
// Replace the above three methods with milling control in 2.0  -----------------------------------------------

snapBF(int currCut, int currX, int currY, int currDep, String slmLabel, brightField, double exposure, String acquName){
		mmc.setExposure(exposure/2);
		switchPattern(slmLabel, brightField);
		//calculate index for current image
		ind = tilingDim  * tilingDim * currCut + currY * tilingDim + currX;
		//snap and save an image
		gui.snapAndAddImage(acquName, ind, 0, 0, currDep);
		print("BF: Depth " + currDep + " Image " + (currCut+1) + " snapped");
		
		//set shutter closed
		mmc.setShutterOpen(false);
		mmc.waitForSystem();
}

snapCurrPattern(int currCut, int currX, int currY, int currPtrn, String slmLabel, pattern, double exposure, String acquName){ 
	//physical slices, curr optical slices, #on each slice, total ims per slice
		mmc.setExposure(exposure);
		switchPattern(slmLabel, pattern);
		//calculate the index of the image
		ind = tilingDim * tilingDim * currCut + currY * tilingDim  + currX  + currPtrn;
		//snap and save an image
		gui.snapAndAddImage(acquName, ind, currX, currY, currPtrn+dep);
		print("Slice: " + (currCut) + " Y: " + (currY) + " X: " + (currX) + " image: " + (currPtrn) + " snapped");
		
		//set shutter closed
		mmc.setShutterOpen(false);
		mmc.waitForSystem();
}


waitForImagingReady(){
	mmc.sleep(500);
	while (Double.valueOf(
		mmc.getProperty("Arduino-Input", "AnalogInput3")
	) > 500){
		print("Waiting for imaging position");
		mmc.sleep(10);
		}
}

imagingTrigger(){
	activateMill();
	waitForImagingReady();
	shutterOff();
}

millingTrigger(){
	activateMill();
	waitForMillingStart();
	shutterOff();
}

//-------------------------------- CODE ABOVE NEEDS TESTING ON THE SETI SYSTEM ---------------------







// Main
gui.closeAllAcquisitions();
mmc.setShutterOpen(false);
mmc.setState("Arduino-Switch", 0);	//all pins LOW
gui.clearMessageWindow();

// load in inputs
inputsObj = inputs();
depthOfSectioning = inputsObject.depthOfSectioning;
depth = inputsObject.depth;
tilingDim = inputsObject.tilingDim;
exposure = inputsObject.exposure; 
inputsObject.objective = inputsObject.objective;
xTiles = inputsObject.xTiles;
yTiles = inputsObject.yTiles;
zStepSize = inputsObject.zStepSize;
rootDir = inputsObject.rootDir;
dlpPatternPath = inputsObject.dlpPatternPath;
show = inputsObject.show;
save = inputsObject.save;
validity_check = inputsObj.validity_check;

// Setting up Variables 
// naming convention can be changed for 2.0 since XYZ information in position file -------------------------------
acquName = inputsObject.acquName + " " + inputsObject.objective + "x_" + exposure+"ms_" + 
	xTiles + "x_" + yTiles + "y_" + ceil(depthOfSectioning/zStepSize) + "z_" + 
	zStepSize + "um_cuts";

nrFrames = 0;  
nrChannels = 3;
nrSlices = 3;
nrPositions = 1 //(numPatterns + bright field) * depths

cuts = ceil(depthOfSectioning/zStepSize);



// Load DLP Patterns
ArrayList dlp_patterns = new ArrayList();
dlp_patterns = dlpPatternInitialization(dlpPatternPath, validity_check);




//--------------------------------- CODE BELOW NEEDS TESTING ON THE SETI SYSTEM --------------------

slmLabel = mmc.getSLMDevice();

// Process begins
gui.openAcquisition(acquName, rootDir, nrFrames, nrChannels, nrSlices, nrPositions, show, save);

// For each cut
for(int i = 0; i < cuts; i++){
	print("slice: " + i);
	// initiate arduino pin after machine cycle. 0 for LOW at all pins, 1 for HIGH at pin 8
	mmc.setState("Arduino-Switch", 0);
	mmc.setShutterOpen(false); // all 
	// For each depth and XY Position
	for (int j = 0; j < depth; j++){
		for (int y = 0; y < tilingDim; y++){
			bfFlag = true;
			for (int x = 0; x < tilingDim; x++){
				for (pattern : dlp_patterns){
					imagingTrigger();
					if (bfFlag){
						snapBF(i, x, y, j, slmLabel, pattern, exposure, acquName);
					}else{
						snapCurrPattern(i, x, y, j, slmLabel, pattern, exposure, acquName);
					}
				}
			}
		}
	}


	// after images taken, trigger the milling cycle
	millingTrigger();

	// wait for the milling to finish. Check on the status every 500ms
	while (Double.valueOf(
			mmc.getProperty("Arduino-Input", "AnalogInput5")
		) < 500) {
		mmc.sleep(500);
	}
	// When finished,
	print("Milling Done");
	mmc.sleep(2000);
}



//-------------------------------- CODE ABOVE NEEDS TESTING ON THE SETI SYSTEM ---------------------







// After all cuts done, close aquisition
gui.closeAllAcquisitions();
mmc.setShutterOpen(false);
mmc.setState("Arduino-Switch", 0);	//all pins LOW

print("ACQUISITION Done\n");