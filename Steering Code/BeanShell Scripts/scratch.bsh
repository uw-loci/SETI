
// Initialize the DLP Patterns
dlpPatternInitialization(String dlpPatternPathOrig, ArrayList dlp_patterns, int patDim1, int patDim2, boolean validity_check){

	if(validity_check){
		print("Start DLP Initialization");
	}

	ArrayList img_load_list = new ArrayList();
	File dlpPatternPath = new File(dlpPatternPathOrig);
	// Check correct folder
	if (validity_check){
		print(dlpPatternPath);
	}

	// Get Path to Sub-Image Patterns
	img_load_list = imgFileSearch( ".*.bmp", dlpPatternPath, img_load_list );
	// Get Path to BrightField Reference File
	bf_path = bfImgFileSearch(".*.bmp", dlpPatternPathOrig, validity_check);
	
	//Check correct files found
	if (validity_check){
		for (int i = 0; i < img_load_list.size(); i++){
		  print(img_load_list.get(i));
		}
		print(bf_path);
	}
	
	// Load Patterns for the DLP
	dlp_patterns = loadAllPatterns(bf_path, img_load_list, dlp_patterns, patDim1, patDim2, validity_check);
	return dlp_patterns;
}









// Imports
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import java.lang.String;
import ij.IJ; 
import ImageConverter;
import org.micromanager.projector.ProjectorActions;
import org.micromanager.projector.internal.devices.SLM;



//------------------ INPUTS ----------------------------------------
inputs(){
	
	double depthOfSectioning = 20;	// total depth of physical sectioning in um (10um per cut).
								//eg: 200 for 200um and 20 cuts
	double imgDepth = 1;	// including the top surface, how many optical slices (10 um each)?  
	int tilingDim = 1;	// How Big a square will be tiled. NOTE: matched G Code only supports 3x3 at the moment
	
	// set camera exposure in ms				
	double exposure = 1; 
	int objective = 20;
	double zStepSize = 10; // in um 

	String acquName = "2022-09-16-Test";  //name of folder generated
	
	
	// NOTE! All File paths must use / or \\ instead of \ on Windows
	
	String rootDir = "C:/Users/admin2/Box Sync/SETI/";
	//rootDir = "C:/Users/admin2/Desktop/Acquisitions"; //address of mother folder
	
//	String dlpPatternPath = "C:/Users/admin2/Documents/GitHub/SETI/Steering Code/Patterns/1920x1080/3 Sub Image Perfect Bar 21 Pixels 0 Aperture 0deg Rotation";	// Folder Containg Patterns for DLP
	String dlpPatternPath = "C:/Users/User/Documents/GitHub/SETI/Steering Code/Patterns/1920x1080/3 Sub Image Perfect Bar 21 Pixels 0 Aperture 0deg Rotation";

	// Dimensions of Pattern Image File
	int patDim1 = 1920;
	int patDim2 = 1080;

	show = true;	// to display every image taken as if you clicked snap
	save = true;	// to save the images
	validity_check = true; // to print various checks to the command line 

	return this;
}
//--------------- END INPUT ----------------------------------------





//------------------ Methods ---------------------------------------
// Find the Pattern Files
imgFileSearch( String fileType, File folder, ArrayList result ){
	
	File[] files = folder.listFiles();
	if (files !=null){
		for (File f : files){
			if (f.isFile()) {
				if (f.getName().matches(fileType)) {
					result.add(f.getAbsolutePath());
				}
			}
		}
	}

	return result; 
}

// Find the BrightField Reference File
bfImgFileSearch( String fileType, String folder, boolean validity_check ){

	bfpath = false;
	if (validity_check){
		print("System File Seperator: " + File.separator);
	}
	folder = folder.replace("\\", File.separator);
	folder = folder.replace("/", File.separator);
	
	if (validity_check){
		print(folder);
	}
	
	int sep = folder.lastIndexOf(File.separator);
	folder = folder.substring(0,sep);
	// Check seperator is correct
	if (validity_check){
		print(folder);
	}

	File bfpath = new File(folder);
	File[] files = bfpath.listFiles();
	if (files !=null){
		for (File f : files){
			if (f.isFile()) {
				if (f.getName().matches(fileType)) {
					 return f.getAbsolutePath();
				}
			}
		}
	}
	
	return bfpath;
}





//Read Image as Byte[][]
imgReadByte(imgSource, int patDim1, int patDim2, boolean validity_check){
	FileInputStream in = new FileInputStream(imgSource);
	ByteArrayOutputStream bos = new ByteArrayOutputStream();
	byte[] buffer = new byte[1024];
	for (int i; (i = in.read(buffer)) != -1; ) {
  		bos.write(buffer, 0, i);
	}
	in.close();
	byte[] imageDataTemp = bos.toByteArray();
	bos.close();

	if (validity_check){
		print("Original Read In Length: " + imageDataTemp.length);
	}
	
	// Remove meta Data by only keeping the dimensional bytes
	patOffset = imageDataTemp.length - (patDim1 * patDim2);
	if (validity_check){
		print("Index Offset for Meta Data: " + patOffset);
	}

	imageDataTemp = Arrays.copyOfRange(imageDataTemp, patOffset, imageDataTemp.length);
	
	if (validity_check){
		print("Meta Data Stripped Length: " + imageDataTemp.length);
	}

	// Reshape read in data from a byte[] to a byte[][]
	imageData = reshape(imageDataTemp, patDim1, patDim2);
	if(validity_check){
		print("Reshaped Dim2: " + imageData[0].length);
		print("\n");
	}
	return imageData;
}


// Reshape a 1D byte array to a 2D byte array
byte[][] reshape(A1D, int m, int n){
	int origM = A1D.length;
	if(origM != m*n){
		throw new Exception("New matrix must be of same area as matix A");
	}
	byte[][] B = new byte[m][n];
	int index = 0;
	for(int i = 0;i<n;i++){
		for(int j = 0;j<m;j++){
			B[j][i] = A1D[index++];
		}
	}
	return B;
}










// Load all the Patterns Found into a Single Array
loadAllPatterns(String bfPattern, ArrayList subPatterns, ArrayList dlp_patterns, int patDim1, int patDim2, boolean validity_check) {
	File bfPatternFile = new File(bfPattern);

	dlp_patterns.add(imgReadByte(bfPatternFile, patDim1, patDim2, validity_check));
	for (p : subPatterns ){
		dlp_patterns.add(imgReadByte(p, patDim1, patDim2, validity_check));
	}

	if (validity_check){
		print("Number of Patterns Total: " + dlp_patterns.size());
	}

	return dlp_patterns;
}

// Initialize the DLP Patterns
dlpPatternInitialization(String dlpPatternPathOrig, ArrayList dlp_patterns, int patDim1, int patDim2, boolean validity_check){

	if(validity_check){
		print("Start DLP Initialization");
	}

	ArrayList img_load_list = new ArrayList();
	File dlpPatternPath = new File(dlpPatternPathOrig);
	// Check correct folder
	if (validity_check){
		print(dlpPatternPath);
	}

	// Get Path to Sub-Image Patterns
	img_load_list = imgFileSearch( ".*.bmp", dlpPatternPath, img_load_list );
	// Get Path to BrightField Reference File
	bf_path = bfImgFileSearch(".*.bmp", dlpPatternPathOrig, validity_check);
	
	//Check correct files found
	if (validity_check){
		for (int i = 0; i < img_load_list.size(); i++){
		  print(img_load_list.get(i));
		}
		print(bf_path);
	}
	
	// Load Patterns for the DLP
	dlp_patterns = loadAllPatterns(bf_path, img_load_list, dlp_patterns, patDim1, patDim2, validity_check);
	return dlp_patterns;
}




















// Main
// load in inputs
inputsObject = inputs();
depthOfSectioning = inputsObject.depthOfSectioning;
imgDepth = inputsObject.imgDepth;
tilingDim = inputsObject.tilingDim;
exposure = inputsObject.exposure; 
inputsObject.objective = inputsObject.objective;
zStepSize = inputsObject.zStepSize;
rootDir = inputsObject.rootDir;
dlpPatternPath = inputsObject.dlpPatternPath;
show = inputsObject.show;
save = inputsObject.save;
validity_check = inputsObject.validity_check;
int patDim1 = inputsObject.patDim1;
int patDim2 = inputsObject.patDim2;

// Setting up Variables 
cuts = Math.ceil(depthOfSectioning/zStepSize);
// naming convention can be changed for 2.0 since XYZ information in position file -------------------------------
acquName = inputsObject.acquName + " " + inputsObject.objective + "x_" + (int)(exposure)+"ms_" + 
	tilingDim + "x_" + tilingDim + "y_" + (int)cuts + "z_" + 
	(int)(zStepSize) + "um_cuts";

nrFrames = 0;  
nrChannels = 3;
nrSlices = 3;
nrPositions = 1; //(numPatterns + bright field) * depths

if(validity_check){
	print("\nVariables Initialized");
}

// Load DLP Patterns
ArrayList dlp_patterns = new ArrayList();
dlp_patterns = dlpPatternInitialization(dlpPatternPath, dlp_patterns, patDim1, patDim2, validity_check);


// After all cuts done, close aquisition
print("ACQUISITION Done\n");